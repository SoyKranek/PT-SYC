PRESENTACIÓN DEL PROYECTO: APLICACIÓN DE SORTEO (Modo aprendiz)

1) Qué me pidieron (requisitos de la prueba)
- Un formulario público para que cualquier persona mayor de edad se inscriba al sorteo.
  Datos obligatorios: Tipo y número de documento, nombres y apellidos, fecha de nacimiento, dirección, teléfono, correo.
  Adjuntar imagen o PDF del documento de identidad.
- Guardar todo en una base de datos con modelo entidad-relación (ER).
- Un usuario administrador que se autentique (usuario/clave) y luego:
  - Vea el listado de inscripciones (por fecha y nombre).
  - Entre al detalle de cada inscripción, vea la información completa y el archivo adjunto.
  - Cambie el estado de la inscripción a Aceptada o Rechazada.
- Punto extra: al aceptar o rechazar, enviar un correo o SMS al usuario.
- Preferencias: Backend en C#, frontend con cualquier framework, validación de datos, UI agradable.

2) Qué entregué (resumen)
- Backend en C# con ASP.NET Core Web API, Entity Framework Core y SQL Server LocalDB.
  - Autenticación con JWT, contraseña admin hasheada con BCrypt.
  - API REST con endpoints públicos y protegidos por rol.
  - Subida y servicio de archivos (imagenes/PDF) desde wwwroot/uploads.
  - Servicio de correo SMTP para notificar cambios de estado.
- Frontend en React + TypeScript.
  - Formulario de inscripción con validación básica.
  - Login de administrador, dashboard (lista con estados y métricas) y página de detalle (ver/descargar documento y cambiar estado).
  - UX moderna con CSS.
- Base de datos relacional (SQL Server) con índices de unicidad y seed del administrador.

3) Por qué lo hice así (decisiones)
- ASP.NET Core + EF Core: rápido de levantar, buena integración con SQL Server, sencillo para autenticación y validación.
- JWT: estándar para SPAs; permite proteger endpoints del admin fácilmente.
- BCrypt: práctica segura para almacenar contraseñas.
- Guardado de archivos en wwwroot/uploads: simple para desarrollo; se puede migrar a S3/Azure Blob en producción.
- React + TS: tipos fuertes en el cliente, componente reusable y buen DX.
- CORS abierto en desarrollo y Swagger para probar/explicar la API.

4) Arquitectura (capas y responsabilidades)
Backend (proyecto SorteoAPI)
- Models: entidades de la BD.
  - Usuario: datos personales, ruta del documento, fecha de solicitud, estado, comentario admin.
  - Administrador: usuario, password hash, nombre, email, activo.
- Data: ApplicationDbContext (EF Core).
  - Define DbSet<>, longitudes, índices únicos y seed del admin (usuario: admin, pass: admin123).
- DTOs: objetos de transferencia entre API y frontend.
  - UsuarioInscripcionDTO / UsuarioListaDTO / UsuarioDetalleDTO / CambioEstadoDTO.
  - LoginDTO / LoginResponseDTO.
- Services (lógica de negocio):
  - AuthService: login de admin y generación de JWT.
  - UsuarioService: lista, detalle, cambio de estado (envía correo), guardar documento y validar edad.
  - EmailService: envío SMTP (configurable por appsettings o secrets). Tiene método de prueba.
- Controllers (endpoints):
  - AuthController: POST /api/Auth/login.
  - UsuariosController:
    - Público: POST /api/Usuarios/inscripcion (multipart/form-data).
    - Admin: GET /lista, GET /detalle/{id}, PUT /cambiar-estado, GET /documento/{nombre}.
    - Admin: POST /test-email (para probar SMTP).
- Program.cs: DI, EF Core, JWT, CORS, StaticFiles, Swagger + Authorize, redirect / -> /swagger.

Frontend (proyecto sorteofrontend)
- types: interfaces TS que reflejan los DTOs del backend.
- services/api.ts: Axios con baseURL desde .env.local y token por interceptor; maneja 401.
- components:
  - FormularioInscripcion: formulario público con archivo y validación (18+ en el backend, max-date en UI).
  - LoginAdmin: obtiene token y lo guarda en localStorage.
  - DashboardAdmin: lista inscripciones, contadores, navegación al detalle.
  - DetalleUsuarioAdmin: ver datos completos, previsualizar/descargar documento y cambiar estado con comentario.
- App.tsx: rutas y ProtectedRoute (restringe a quien tenga token).
- index.css y CSS de componentes: estilos limpios y responsivos.

5) Modelo de datos (relacional)
- Base: SQL Server LocalDB, DB: SorteoDB.
- Tablas: Usuarios y Administradores (sin FK entre sí).
- Índices de unicidad:
  - Usuarios: (TipoDocumento, NumeroDocumento) y CorreoElectronico.
  - Administradores: Usuario y Email.
- ER simple: dos entidades independientes para cumplir requerimientos (inscripciones y control de admin).

6) Seguridad
- Autenticación: JWT con claims (Id, Usuario, Rol, Nombre), expira a 8h (ajustable).
- Autorización: endpoints de admin marcados con [Authorize(Roles = "Administrador")].
- Contraseñas: BCrypt.
- CORS: abierto en dev (se ajusta en producción).

7) Manejo de archivos
- Subida validada por extensión (.jpg, .jpeg, .png, .pdf).
- Se almacenan con nombre único GUID en wwwroot/uploads.
- GET /api/Usuarios/documento/{nombre} devuelve el archivo con mimetype correcto (protegido por rol).

8) Envío de correos (SMTP)
- EmailService usa configuración Smtp. Si faltan datos, se omite el envío pero NO falla la operación.
- Se envía correo al cambiar estado (Aceptada/Rechazada) a la dirección del usuario.
- Método de prueba: POST /api/Usuarios/test-email?to=destinatario.
- Recomendación para Gmail: activar 2FA y usar App Password (no la contraseña normal).

9) Cómo se ejecuta localmente (desarrollo)
- Backend:
  1. cd SorteoAPI
  2. dotnet run --urls http://localhost:5028
  3. Abrir http://localhost:5028/swagger (redirige desde /).
- Frontend:
  1. cd sorteofrontend
  2. Crear/editar .env.local con: REACT_APP_API_BASE_URL=http://localhost:5028/api
  3. npm start
  4. Abrir http://localhost:3000

10) Flujo end-to-end
- Inscripción (público): llenar formulario y adjuntar archivo → guarda BD + archivo.
- Login admin: admin/admin123 → token en localStorage.
- Dashboard: ver lista por fecha y estados.
- Detalle: ver datos completos, previsualizar/descargar documento, cambiar estado (dispara email si SMTP).

11) Cómo probar SMTP
- Configurar en appsettings.json (o user-secrets): Host, Port, User, Pass (App Password si Gmail), From, Ssl.
- Reiniciar backend.
- En Swagger: Authorize con token y ejecutar POST /api/Usuarios/test-email.
- Revisar bandeja de entrada y consola (logs de éxito o error).

12) Validaciones
- Backend: DataAnnotations (requeridos, email, phone) y lógica (edad >= 18, extensiones de archivo, unicidad en BD).
- Frontend: required/placeholder y límites de fecha (UX); la validación real de edad/duplicados la hace el backend.

13) Decisiones de diseño (por qué)
- Simpleza sobre-optimización: 2 tablas bastan para la prueba; fácil de explicar y mantener.
- JWT + rol "Administrador": separa claramente rutas públicas de privadas.
- wwwroot para archivos: rápido de implementar en local; listo para migrar a un servicio de archivos.
- Axios con interceptor: centraliza auth y manejo de 401.
- CSS puro: suficiente para una UI agradable y liviana.

14) Qué mejoraría si tuviera más tiempo
- Migraciones EF Core (en lugar de EnsureCreated) para versionar el esquema.
- Paginación, filtros y búsqueda en el dashboard.
- Límite de tamaño de archivo, verificación antivirus y thumbnails.
- Almacenamiento en la nube (S3/Azure Blob) con enlaces firmados.
- Auditoría (traza de cambios de estado) y notificaciones por SMS vía Twilio.
- Rate limiting/login intentos, logging estructurado (Serilog) y health checks.
- Pruebas unitarias/integración y pipeline de CI/CD.


15) Problemas típicos y solución
- 404 en /: normal; por eso agregué redirect a /swagger.
- 401 en endpoints admin: token ausente o expirado; volver a loguearse.
- Puerto ocupado o exe bloqueado: matar proceso (taskkill /PID <pid> /F), limpiar bin/obj y reintentar.
- SMTP no envía: usar App Password (Gmail), revisar puerto 587/465 y logs.
